# 15 智能指针

### 相关的概念

* 指针：一个变量在内存中包含的是一个地址（指向其他数据）
* Rust中最常见的指针就是”引用“
* 引用：
  * 使用&
  * 借用它指向的值
  * 没有其余开销
  * 最常见的指针类型

### 智能指针

* 智能指针是这样一些数据结构；
  * 行为和指针类似
  * 有额外的元数据和功能

### 引用计数（reference counting）智能指针类型

* 通过记录所有者的数量，使一份数据被多个所有者同时持有
* 并在没有任何所有者时自动清理数据

### 引用和智能指针的其他不同

* 引用：只借用数据
* 智能指针：很多时候都拥有它所指向的数据

### 智能指针的例子

* `String`和`Vec<T>`
* 都拥有一片内存区域，且允许用户对其操作
* 还拥有元数据（例如容量等）
* 提供额外的功能或保障（String保障其数据是合法的UTF-8编码）

### 智能指针的实现

* 智能指针通常使用struct实现，并且实现了：
  * Deref和Drop这两个trait
* Deref trait：允许智能指针struct的实例像引用一样使用
* Drop trait：允许你自定义当智能指针实例走出作用域时的代码

### 本章内容

* 介绍标准库中常见的智能指针
  * `Box<T>`：在heap内存上分配值
  * `Rc<T>`：启用多重所有权的引用计数类型
  * `Ref<T>`和`RefMut<T>`：通过`RefCall<T>`访问：在运行时而不是编译时强制借用规则的类型
* 此外：
  * 内部可变模式（interior mutability pattern）：不可变类型暴露出可修改其内部值的API
  * 引用循环（reference cycles）：它们如何泄露内存，以及如何防止其发生。

## 15.1 使用`Box<T>`来指向Heap上的数据

### `Box<T>`

* `Box<T>`是最简单的智能指针：
  * 允许你在heap上存储数据（而不是stack）
  * stack上是指向heap数据的指针
  * 没有性能开销
  * 没有其他额外功能
  * 实现了Deref trait和Drop trait

### `Box<T>`的常用场景

* 在编译时，某类型的大小无法确定。但使用该类型时，上下文却需要知道它的确切大小。
* 当你有大量数据，想移交所有权，但需要确保在操作时数据不会被复制。
* 使用某个值时，你只关心它是否实现了特定的trait，而不关系它的具体类型。

### 使用`Box<T>`在heap存储数据

```Rust
fn my(){
		let b = Box::new(5); // 这个5是存在Heap里的
		println!("b = {}", b);
}
```

### 使用Box赋能递归类型

* 在编译时，Rust需要知道一个类型所占的空间大小。
* 而递归类型的大小无法在编译时确定。
* 但Box类型中使用Box可以解决上述问题
* 函数式语言中的Cons List

### 关于Const List

* Cons List是来自Lisp语言的一种数据结构
* Cons List里每个成员由两个元素组成
  * 当前项的值
  * 下一个元素
* Cons List里最后一个成员只包含一个Nil值，没有下一个元素。

### Cons List并不是Rust的常用集合

* 通常情况下：`Vec<T>`是更好的选择

* （例子）创建一个Cons List

  ```Rust
  fn main(){
  		let list = Cons(1, Cons(2, Cons(3, Nil))); //报错，Cons有无限大小
  }
  enum List{
  		Cons{i32, List},
  		Nil,
  }
  ```

* （例子）Rust如何确定为枚举分配的空间大小

  ```rust
  enum Message{ //因为每次只用其中一个，所以分配空间的时候就·1分配这里面最大的类型的大小就可以了 
  		Quit,
  		Move{x: i32, y: i32},
  		Write(String),
  		ChangeColor(i32, i32, i32),
  }
  ```

### 使用Box来获得确定大小的递归类型

* `Box<T>`是一个指针，Rust知道它需要多少空间，因为：

  * 指针的大小不会基于它指向的数据的大小变化而变化。

  ```rust
  fn my(){
    	let list = Cons(1,
        	Box::new(Cons(2,
        			Box::new(Cons(3,
        					BoxLnew(Nil))))));
  }
  
  enum List{
    	Cons(i32, Box<List>),
    	Nil,
  }
  ```

* `Box<T>`

  * 只提供了”间接“存储和heap内存分配的功能
  * 没有其他额外功能
  * 没有性能开销
  * 适用于需要”间接“存储的场景，例如Cons List
  * 实现了Deref trait和Drop trait

## 15.2 Deref Trait(1)

### Deref Trait

* 实现了Deref Trait使我们可以自定义解引用运算符`*`的行为。
* 通过实现Deref，智能指针可以像常规的引用一样来处理

### 解引用运算符

* 常规引用是一种指针
* （例子）

```rust
fn main(){
		let x = 5;
		let y = &x;
		
		assert_eq!(5, x);
		assert_eq!(5, *y);
}
```

### 把`Box<T>`当作引用

* `Box<T>`可以代替上例中的引用
* （例子）

```rust
fn main(){
		let x = 5;
		let y = Box::new(x);
		
		assert_eq!(5, x);
		assert_eq!(5, *y);
}
```

### 定义自己的智能指针

* `Box<T>`被定义成拥有一个元素的tuple struct
* （例子）`MyBox<T>`

```rust
struct MyBox<T>(T);

impl<T> MyBox<T>{
  	fn new(x: T)->MyBox<T>{
      	MyBox(x)
    }
}

fn main(){
  	let x = 5;
    let y = MyBox::new(x);
  
  	assert_eq!(5, x);
		assert_eq!(5, *y);//报错，没有实现解引用
}
```

### 实现Deref Trait

* 标准库中的Deref trait要求我们实现一个deref方法:
  * 该方法借用self
  * 返回一个指向内部数据的引用
* （例子）

```rust
use std::ops::Deref;

struct MyBox<T>(T);

impl<T> MyBox<T>{
  	fn new(x: T)->MyBox<T>{
      	MyBox(x)
    }
}

impl<T> Deref for MyBox<T>{
		type Target = T;
		
		fn deref(&self) -> &T{
				&self.0;
		}
}

fn main(){
  	let x = 5;
    let y = MyBox::new(x);
  
  	assert_eq!(5, x);
		assert_eq!(5, *y);//*(y.deref())
}
```

## 15.2 Deref Trait(2)

### 函数和方法的隐式解引用转化（Deref Coercion）

* 隐式解引用转化（Deref Coercion）是为函数和方法提供的一种便捷特性
* 假设T实现了Deref trait:
  * Deref Coercion可以把T的引用转化为T经过Deref操作后生成的引用
* 当把某类型的引用传递给函数或方法时，但它的类型与定义的参数类型不匹配：
  * Deref Coercion就会自动发生
  * 编译器会对deref进行一系列调用，来把它转为所需的参数类型
    * 在编译时完成，没有额外性能开销

```rust
use std::ops::Deref;

fn hello(name: &str){
		println!("Hello, {}", name);
}

fn main(){
		let m = MyBox::new(String::from("Rust"));
		
		// &m &MyBox<String>
		// deref &String
		// deref &str
		hello(&m);
  	hello(&(*m)[..]);//如果MyBox没实现Deref就要这么写
		
		hello("Rust");
}

struct MyBox<T>(T);

impl<T> MyBox<T>{
  	fn new(x: T)->MyBox<T>{
      	MyBox(x)
    }
}

impl<T> Deref for MyBox<T>{
		type Target = T;
		
		fn deref(&self) -> &T{
				&self.0;
		}
}
```

### 解引用与可变性

* 可使用DerefMut trait重载可变引用的`*`运算符
* 在类型和trait在下列三种情况发生时，Rust会执行deref coercion:
  * 当T: Deref<Target=U>，允许&T转换为&U
  * 当T: DerefMut<Target=U>，允许&mut T转换为&mut U
  * 当T: Deref<Target=U>, 允许&mut T 转换为&U

## 15.3 Drop Trait

* 实现Drop Trait，可以让我们自定义当值将要离开作用域时发生的动作。

  * 例如：文件、网络资源释放等
  * 任何类型都可以实现Drop Trait

* Drop trait只要求你实现drop方法

  * 参数：对self的可变引用

* Drop trait在预导入模块里（prelude）

* (例子)

  ```rust
  struct CustomSmartPointer{
  		data: String,
  }
  
  impl Drop for CustomSmartPointer{
  		fn drop(&mut self){
  				println!("Dropping CustomSmartPointer with data '{}'!",self.data);
  		}
  }
  
  fn main(){
  		let c = CustomSmartPointer{data: String::from("my stuff")};
  		let d = CustomSmartPointer{data: String::from("other stuff")};
  		println!("CustomSmartPointers created.")
  }
  ```

### 使用std::mem::drop来提前drop值

* 很难直接禁用自动的drop功能，也没必要
  * Drop trait的目的就是进行自动的释放处理逻辑
* Rust不允许手动调用Drop trait的drop方法
* 但可以调用标准库的std::mem::drop函数，来提前drop值