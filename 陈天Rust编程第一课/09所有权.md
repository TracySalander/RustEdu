我们对所有权有个更深入的了解，掌握了Rc/Arc、RefCell/Mutex/RwLock这些数据结构的用法。

如果想绕过“一个值只有一个所有者”的限制、我们可以使用Rc/Arc这样带引用计数的智能指针。其中，Rc效率很高，但只能使用在单线程环境下；Arc使用了原子结构，效率略低，但可以安全使用在多线程环境下。

然而，Rc/Arc是不可变的，如果想要修改内部的数据，需要引入内部可变性，在单线程环境下，可以在Rc内部使用RefCall；在多线程环境下，可以使用Arc嵌套Mutex或者RwLock的方法。



| 访问方式             | 数据           | 不可变借用 | 可变借用         |
| -------------------- | -------------- | ---------- | ---------------- |
| 单一所有权           | T              | &T         | &mut T           |
| 共享所有权（单线程） | Rc<T>          | &Rc<T>     | 无法得到可变借用 |
| 共享所有权（单线程） | Rc<RefCell<T>> | v.borrow() | v.borrow_mut()   |
| 共享所有权（多线程） | Arc<T>         | &Arc<T>    | 无法得到可变借用 |
| 共享所有权（多线程） | Arc<Mutex<T>>  | v.lock()   | v.lock()         |
| 共享所有权（多线程） | Arc<RwLock<T>> | v.read()   | v.write()        |


