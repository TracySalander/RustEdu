# 所有权问题

## Q: 如果我想创建双向链表，该怎么处理？

Rust标准库有LinkedList，它是一个双向链表的实现。但是当你需要使用链表的时候，可以先考虑一下，__同样的需求是否可以用列表Vec<T>、循环缓冲区VecDeque<T>来实现。__因为，链表对缓存非常不友好，性能会差很多。

如果你只是好奇如何实现双向链表，那么可以用之前讲的Rc/RefCell（第9讲）来实现。对于链表的next指针，你可以用Rc；对于prev指针，可以用Weak。

Weak相当于一个弱化版本的Rc，不参与到引用计数的计算中，而Weak可以upgrade到Rc来使用。如果你用过其它语言的引用计数数据结构，你应该对Weak不陌生，它可以帮我们打破循环引用。

你也许好奇为什么Rust标准库的LinkedList不用Rc/Weak，那是因为标准库直接用NonNull指针和unsafe。

## Q:编译器总告诉我："use of moved value"错误，该怎么破？

这是我们初学Rust时经常会遇到的错误，这个错误是说__你在试图访问一个所有权已经移走的变量。__

对于这样的错误，首先你要判断，这个变量真的需要被移动到另一个作用域下么？如果不需要，可不可以使用借用？如果的确需要引移动给另一个作用域的话：

1. 如果需要多个所有者共享同一份数据，可以使用Rc/Arc，辅以Cell/RefCell/Mutex/RwLock。
2. 如果不需要多个所有者共享，那可以考虑实现Clone甚至Copy。

# 生命周期问题

## Q:为什么我的函数返回一个引用的时候，编译器总是跟我过不去？

函数返回引用时，除非是静态引用，那么这个引用一定和带有引用的某个输入参数有关。输入参数可能是&self、&mut self或者&T/&mut T。__我们要建立正确的输入和返回值之间的关系，这个关系和函数内部的实现无关，只和函数的签名有关。__

比如HashMap的get()方法：

```rust
pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V> 
	where
			K: Borrow<Q>,
			Q: Hash + Eq
```

我们并不用实现它或者知道它如何实现，就可以确定返回值Option<&V>到底跟谁有关系。因为这里只有两个选择：&self或者k: &Q。显然是&self，因为HashMap持有数据，而k只是用来在HashMap里查询的key。

这里为什么不需要使用生命周期参数呢？因为我们之前讲的规则：__当&self/&mut self出现时，返回值的生命周期和它关联。__这是一个很棒的规则，因为大部分方法，如果返回引用，它基本上是引用&self里的某个数据。

如果你能搞明白这一层关系，那么久比较容易处理，函数返回引用时出现的生命周期错误。

当你要返回在函数执行过程中，创建的或者得到的数据，和参数无关，那么__无论它是一个有所有权的数据，还是一个引用，你只能返回带所有权的数据。__对于引用，这就意味着调用clone()或者to_owned()来，从引用中得到所有权。

# 数据结构问题

## Q:为什么Rust字符串这么混乱，有String、&String、&str这么多不同的表述？

我不得不说，这是一个很有误导性的问题，因为这个问题有点胡言乱语的倾向，很容易把人带到沟里。

首先，任何数据结构T，都可以有指向它的引用&T，__所以String跟&String的区别，以及String跟&str的区别，压根是两个问题。__

更好的问题是：为什么有了String，还要有&str?或者，更通用的问题：为什么String、Vec<T>这样存放连续数据的容器，还要有切片的概念呢？

一旦问到点子上，答案不言自喻，因为切片是一个非常通用的数据结构。

用过Python的人都知道：

```python
s = "hello world"
let slice1 = s[:5] # 可以对字符串切片
let slice2 = slice1[1:3] # 可以对切片再切片
print(slice1, slice2) # 打印hello, el
```

这和Rust的String切片何其相似：

```rust
let s = "hello world".to_string();
let slice1 = &s[..5]; //可以对字符串切片
let slice2 = &slice1[1..3]; // 可以对切片再切片
println!("{} {}", slice1, slice2); // 打印 hello el
```

所以&str是String的切片，也可以是&str的切片。它和&[T]一样，没有什么特别的，就是一个带着长度的胖指针，指向了一片连续的内存区域。

你可以这么理解：__切片之于Vec<T>/String等数据，就好比数据库里的视图（view）之于表（table）__

## Q:在课程的示例代码中，用了很多unwrap()，这样可以么？

当我们需要从Option或者Result<T, E>中获得数据时，可以使用unwrap()，这是示例代码出现unwrap()的原因。

如果我们只是写一些学习性质的代码，那么unwrap()是可以接受的，但在生产环境中，除非你可以确保unwrap()不会引发panic!()，否则应该使用模式匹配来处理数据，或者使用错误处理的？操作符。我们后续会有专门一讲聊Rust的错误处理。

那什么情况下我们可以确定unwrap()不会panic呢？如果在做unwrap()之前，__Option<T>或者Result<T, E>中已经有合适的值（Some(T)或者Ok(T)），你就可以做unwrap()。比如这样的代码：

```rust
//假设v是一个Vec<T>
if v.is_empty(){
  return None;
}

//我们现在确定至少有一个数据，所以unwrap是安全的
let first = v.pop().unwrap();
```

## Q: 为什么标准库的数据结构比如Rc/Vec用那么多unsafe，但别人总是告诉我，unsafe不好？

好问题。C语言的开发者也认为asm不好，但C的很多库里也大量使用asm。

标准库的责任是，在保证安全的情况下，即使牺牲一定的可读性，也要用最高效的手段来实现要实现的功能；同时，为标准库的用户提供一个优雅、高级的抽象，让他们可以在绝大多数场合下写出漂亮的代码，无需和丑陋打交道。

Rust中，unsafe代码把程序的正确性和安全性交给了开发者来保证，而标准库的开发者花费了大量的精力和测试来保证这种正确和安全性。而我们自己撰写unsafe代码时，否则，有可能疏于对开发情况的考虑，写出了有问题的代码。

所以只要不是必须，建议不要写unsafe代码。__毕竟大部分我们要处理的问题，都可以通过良好的设计、合适的数据结构和算法来实现。__

## Q: 在Rust例，我如何声明全局变量呢？

const和static都可以用于声明全局变量。但注意，除非使用unsafe, static无法作为mut使用，因为这意味着它可能在多个线程下被修改，所以不安全：

```rust
static mut COUNTER: u64 = 0;

fn main(){
	COUNTER += 1; //编译不过，编译器告诉你需要使用unsafe
}
```

如果你的确想用可写的全局变量，可以用Mutex<T>，然而，初始化它很麻烦，这时，你可以用一个库lazy_static。

