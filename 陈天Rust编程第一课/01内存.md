今天我们重新回顾基础概念，分析了栈和堆的特点

对于存入栈上的值，它的大小在编译期就需要确定。栈上存储的变量生命周期在当前调用栈的作用域内，无法跨调用栈引用。

堆可以存入大小未知或者动态伸缩的数据类型。堆上存储的变量，其生命周期从分配开始，一直到释放时才结束，因此堆上的变量允许在多个调用栈之间引用。但也导致堆变量的管理非常复杂，
手工管理会引发很多内存安全性问题，而自动管理，无论是GC还是ARC，都有性能损耗和其他问题。

一句话对比总结就是：栈上存放的数据是静态的，静态大小，静态生命周期；堆上存放的数据是动态的，动态大小，动态生命周期。

### 思考题：
#### 如果有一个数据结构需要在多个线程中访问，可以把它放在栈上吗？为什么？
在多线程场景下，每个线程的生命周期是不固定的，无法在编译期知道谁先结束后结束，所以你不能把属于某个线程A调用栈上的内存共享给线程B，因为A可能先于B结束。这时候，只能使用堆内存。这里有一个例外，
如果结束的顺序是确定的，那么可以共享，比如scoped thread；
#### 可以使用指针引用栈上的某个变量吗？如果可以，在什么情况下可以这么做?
而同一个调用栈下，main()调用hello()，再调用world()，编译器很清楚，world()会先结束，之后是hello()，最后是main()。所以在world()下用指针引用hello()或者main()内部的变量没有问题，
这个指针必然先于它指向的值结束。这个两个问题的实质是我们要搞明白哪些东西在编译期可以确定它们的关系或者因果，哪些只能在运行期确定。
