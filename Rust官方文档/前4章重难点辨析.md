标量数据用贴便签的例子

其他类型数据用护照和人的例子



let声明变量，仅有let变量是不可变的（强力胶贴标签）

如果let加了mut则是可变的变量（贴便签纸）

const定义常量 const PI = 3.14，地球毁灭了，便签没了，但是PI永远都在那里并且等于3.14（无上之真理）



标量数据类型：整数，浮点，布尔，字符（全都存在Stack上，简单，编译时就知道大小的放Stack里)

复合类型：元组，数组(编译时来不知道大小的放Heap里， 然后让Stack指着？看具体情况，里面存的是什么)

特殊类型：String（这属于编译时不知道大小的，放在Heap里）

​				切片（压根儿没所有权）



Case1: -> 1, 2 （两张强力胶贴在同一个东西上叫不同的名字但是指的是一个东西）（针对Stack）

```rust
fn main() {
    let a = 1;
    let b = a+1;
    println!("{}, {}", a, b);
}

```

Case2: -> 2.2 （两张强力胶标签贴在同一个东西上叫一个名字，以最新的为准）（针对Stack）

```Rust
fn main() {
    let a = 1;
    let a = a+1;
    println!("{}, {}", a, a);
}

```

Case3: -> 报错，a不行了，用不了 （同一个人护照到期换新护照，前一个护照不能用了，只能用新的）(Move 所有权移动 = 浅拷贝 + 原来护照失效) （针对Heap）

```rust
fn main() {
    let a = String::from("hello");
    let b = a;
    println!("{}, {}", a, b);
}

```

Case4: -> hello, hello（把护照对应的人克隆了一个，然后给这个人办了一个他的护照，跟之前那个人的护照id不同）（深拷贝）（针对Heap）（Stack上就是复制Copy，不是克隆。其实就Case1把b = a+1改为b = a，标量类型深拷贝和浅拷贝是一样的，都是在Stack里直接用就行了。特殊的如果Tuple中的所有字段都是标量类型，那么也可以，因为只要存的内容在编译时可以推断大小就可以有Copy操作）

```Rust
fn main() {
    let a = String::from("hello");
    let b = a.clone();
    println!("{}, {}", a, b);
}

```

引用和借用（其实就是把引用作为函数参数，借用是特殊情况下的引用）：

引用加&符号，例如参数类型是&String，允许用某些值但不取得其所有权，s指向s1(s1是Stack中的一个指针，指向Heap中的具体内容)

s相当于一个公证书，上面写了护照（s1）是有效地，有公证号码。用公证书可以查到这个人，但是却本身并没有对护照有任何更改，因此不改变所有权。
