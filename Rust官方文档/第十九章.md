# 第十九章 高级特性

## 主要内容

* 不安全Rust
* 高级Trait
* 高级类型
* 高级函数和闭包
* 宏

## 19.1 不安全Rust

### 匹配命名 变量

* 隐藏着第二个语言，它没有强制的内存安全保证：Unsafe Rust（不安全的Rust）
  * 和普通的Rust一样，但提供了额外的”超能力“
* Unsafe Rust存在的原因
  * 静态分析是保守的。
    * 使用Unsafe Rust：我知道自己在做什么，并承担相应风险
  * 计算机硬件本身就是不安全的，Rust需要能够进行底层系统编程

### Unsafe超能力

* 使用unsafe关键字来切换到unsafe Rust，开启一个块，里面放着unsafe代码
* Unsafe Rust里可执行的四个动作（unsafe超能力）
  * 解应用原始指针
  * 调用unsafe函数或方法
  * 访问或修改可变的静态变量
  * 实现unsafe trait
* 注意：
  * unsafe并没有关闭借用检查或停用其他安全检查
  * 任何内存安全相关的错误必须留在unsafe块里
  * 尽可能隔离unsafe代码，最好将其封装在安全的抽象里，提供安全的API

### 解引用原始指针

* 原始指针
  * 可变的: *mut T
  * 不可变的: *const T。意味着指针在解引用后不能直接对其进行赋值
  * 注意：这里的*不是解引用符号，它是类型名的一部分。
  * 与引用不同，原始指针：
    * 允许通过同时具有不可变和可变指针或多个指向同一个位置的可变指针来忽略借用规则
    * 无法保证能指向合理的内存
    * 允许为null
    * 不实现任何自动清理
  * 放弃保证的安全，换取更好的性能/与其它语言或硬件接口的能力
* 为什么要用原始指针
  * 与C语言进行接口
  * 构建借用检查器无法理解的安全抽象

### 调用unsafe函数或方法

* unsafe函数或方法：在定义前加上unsafe关键字
  * 调用前需要手动满足一些条件（主要靠看文档），因为Rust无法对这些条件进行验证
  * 需要在unsafe块里进行调用

### 创建unsafe代码的安全抽象

* 函数包含unsafe代码并不意味着需要将整个函数标记为unsafe
* 将unsafe代码包裹在安全函数中是一个常见的抽象

### 使用extern函数调用外部代码

* extern关键字：简化创建和使用外部函数接口（FFI）的过程。
* 外部函数接口（FFI, Foreign Function Interface），它允许一种编程语言定义函数，并让其它编程语言能调用这些函数
* 应用二进制接口（ABI, Application Binary Interface）：定义函数在汇编层的调用方式
* ”C” ABI是最常见的ABI：它遵循C语言的ABI

### 从其它语言调用Rust函数

* 可以使用extern创建接口，其它语言通过它们可以调用Rust的函数
* 在fn前添加extern关键字，并指定ABI
* 还需添加#[no_mangle]注解：避免Rust在编译时改变它的名称

### 访问或修改一个可变静态变量

* Rust支持全局变量，但因为所有权机制可能产生某些问题，例如数据竞争
* 在Rust里，全局变量叫做静态（static）变量

### 静态变量

* 静态变量与常量类似
* 命名：SCREAMING_SNAKE_CASE
* 必须标注类型
* 静态变量只能存储'static生命周期的引用，无需显式标注
* 访问不可变的静态变量是安全的

### 常量和不可变静态变量的区别

* 静态变量：有固定的内存地址，使用它的值总会访问同样的数据
* 常量：允许使用它们的时候对数据进行复制
* 静态变量：可以是可变的，访问和修改静态可变变量是不安全（unsafe）的

### 实现不安全（unsafe）trait

* 当某个trait中存在至少一个方法拥有编译器无法校验的不安全因素时，就称这个trait是不安全的
* 声明unsafe trait：在定义前加unsafe关键字
  * 该trait只能在unsafe代码块中实现

### 何时使用unsafe代码

* 编译器无法保证内存安全，保证unsafe代码正确并不简单
* 有充足理由使用unsafe代码时，就可以这样做
* 通过显式标记unsafe，可以在出现问题时轻松的定位



## 19.2 高级Trait

### 在Trait定义中使用关联类型来指定占位类型

* 关联类型（associated type）是Trait中的类型占位符，它可以用于Trait的方法签名中：
  * 可以定义出包含某些类型的Trait，而在实现前无需知道这些类型是什么

### 关联类型与泛型的区别

| 泛型                                              | 关联类型                        |
| ------------------------------------------------- | ------------------------------- |
| 每次实现Trait时标注类型                           | 无需标注类型                    |
| 可以与一个类型多次实现某个Trait（不同的泛型参数） | 无法为单个类型多次实现某个Trait |

### 默认泛型参数和运算符重载

* 可以在使用泛型参数时为泛型指定一个默认的具体类型。
* 语法：<PlaceholderType=ConcreteType>
* 这种技术常用于运算符重载（operator overloading）
* Rust不允许创建自己的运算符及重载任意的运算符
* 但可以通过实现std::ops中列出的那些trait来重载一部分相应的运算符

### 默认泛型参数得主要应用场景

* 扩展一个类型而不破坏现有代码
* 允许在大部分用户都不需要的特定场景下进行自定义

### 完全限定语法（Fully Qualified Syntax）如何调用同名方法

* 完全限定语法：<Type as Trait>::function(receiver_if_method, netx_arg, ...);
  * 可以在任何调用函数或方法的地方使用
  * 允许忽略那些从其它上下文能推导出来的部分
  * 当Rust无法区分你期望调用哪个具体实现的时候，才需使用这种语法

### 使用supertrait来要求trait附带其它trait的功能

* 需要在一个trait中使用其他trait的功能：
  * 需要被依赖的trait也被实现
  * 那个被间接依赖的trait就是当前trait的supertrait

### 使用newtype模式在外部类型上实现外部trait

* 孤儿规则：只有当trait或类型定义在本地时，才能为该类型实现这个trait
* 可以通过newtype模式来绕过这一规则
  * 利用tuple struct（元组结构体）创建一个新的类型

## 19.3 高级类型

### 使用newtype模式实现类型安全和抽象

* newtype模式可以：
  * 用来静态的保证各种值之间不会混淆并表明值的单位
  * 为类型的某些细节提供抽象能力
  * 通过轻量级的封装来隐藏内部实现细节

### 使用类型别名创建类型同义词

* Rust提供了类型别名的功能：
  * 为现有的类型产生另外的名称（同义词）
  * 并不是一个独立的类型
  * 使用type关键字
* 主要用途：减少代码字符重复

### Never类型

* 有一个名为!的特殊类型：
  * 它没有任何值，行话称为空类型（empty type）
  * 我们倾向于叫它never类型，因为它在不返回的函数中充当返回类型
* 不返回值的函数也被称作发散函数（diverging function）

### 动态大小和Sized Trait

* Rust需要在编译时确定为一个特定类型的值分配多少空间
* 动态大小的类型（Dynamically Sized Types：DST）的概念：
  * 编写代码时使用只有在运行时才能确定大小的值
* str是动态大小的类型（注意不是&str）：只有运行时才能确定字符串的长度
  * 下面的代码无法正常工作：
    * let s1: str = "Hello there!";
    * let s2: str = "How's it going?";
  * 使用&str来解决
    * str的地址
    * str的长度

### Rust使用动态大小类型的通用方式

* 附带一些额外的元数据类存储动态信息的大小
  * 使用动态大小类型时总会把它的值放在某种指针后边

### 另外一种动态大小的类型：trait

* 每个trait都是一个动态大小的类型，可以通过名称对其进行引用
* 为了将trait用作trait对象，必须将它放置在某种指针之后
  * 例如&dyn Trait或Box<dyn Trait>(Rc <dyn Trait>)之后

### Sized trait

* 为了处理动态大小的类型, Rust提供了一个Sized trait来确定一个累心的大小在编译时是否已知
  * 编译时可计算出大小的类型会自动实现这一trait
  * Rust还会为每一个泛型函数隐式的添加Sized约束
* 默认情况下，泛型函数只能被用于编译时已经知道大小的类型，可以通过特殊语法解除这一限制

### ?Sized trait约束

* T可能是也可能不是Sized
* 这个语法只能用在Sized上面，不能被用于其它trait

## 19.4 高级函数和闭包

### 函数指针

* 可以将函数传递给其他函数
* 函数在传递过程中会被强制转换成fn类型
* fn类型就是“函数指针(function pointer)”

### 函数指针与闭包的不同

* fn是一个类型，不是一个trait
  * 可以直接指定fn为参数类型，不用声明一个以Fn trait为约束的泛型参数
* 函数指针实现了全部3种闭包trait(Fn, FnMut, FnOnce)：
  * 总是可以把函数指针用作参数传递给一个接收闭包的函数
  * 所以，倾向于搭配闭包trait的泛型类编写函数：可以同时接收闭包和普通函数
* 某些情景，只想接收fn而不接收闭包：
  * 与外部不支持闭包的代码交互：C函数

### 返回闭包

* 闭包使用trait进行表达，无法在函数中直接返回一个闭包，可以将一个实现了该trait的具体类型作为返回值。

## 19.5 宏

### 宏 macro

* 宏在Rust里指的是一组相关特性的集合称谓：
  * 使用macro_rules!构建的声明宏（declarative macro）
  * 3种过程宏
    * 自定义#[derive]宏，用于struct或enum，可以为其指定随derive属性添加的代码
    * 类似属性的宏，在任何条目上添加自定义属性
    * 类似函数的宏，看起来像函数调用，对其指定为参数的token进行操作

### 函数与宏的差别

* 本质上，宏是用来编写可以生成其他代码的代码（元编程, metaprogramming）

* 函数在定义签名时，必须声明参数的个数和类型，宏可处理可变的参数
* 编译器会在解释代码前展开宏
* 宏的定义比函数复杂得多，难以阅读、理解、维护
* 在某个文件调用宏时，必须提前定义宏或将宏引入当前作用域：
* 函数可以在任何位置定义并在任何位置使用

### macro_rules!声明宏（弃用）

* Rust中最常用的宏形式：声明宏
  * 类似match的模式匹配
  * 需要使用macro_rules!

### 基于属性来生成代码的过程宏

* 这种形式更像函数（某种形式的过程）一些
  * 接收并操作输入的Rust代码
  * 生成另外一些Rust代码作为结果
* 三种过程宏：
  * 自定义派生
  * 属性宏
  * 函数宏
* 创建过程宏时：
  * 宏定义必须单独放在它们自己的包中，并使用特殊的包类型

### 自定义derive宏

* 需求：
  * 创建一个hello_macro包，定义一个拥有关联函数hello_macro的HelloMacro trait
  * 我们提供一个能自动实现trait的过程宏
  * 在它们的类型上标注#[derive(HelloMacro)]，进而得到hello_macro的默认实现

### 类似属性的宏

* 属性宏与自定义derive宏类似
  * 允许创建新的属性
  * 但不是为derive属性生成代码
* 属性宏更加灵活
  * derive只能用于struct和enum
  * 属性宏可以用于任意条目，例如函数

### 类似函数的宏

* 函数宏定义类似于函数调用的宏，但比普通函数更加灵活
* 函数宏可以接收TokenStream作为参数
* 与另外两种过程宏一样，在定义中使用Rust代码来操作TokenStream

