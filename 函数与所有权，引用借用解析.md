# 函数与所有权，引用借用

## 总结

简单类型不考虑所有权，复杂类型直接用转移所有权，引用不转移所有权。

函数内部造的复杂类型，返回值必须返回其所有权，不能返回引用，因为出了函数，这个类型的对象就死了。。。

可变引用只能有一个，不可变引用可以有多个，不可变引用和可变引用只能二选一。

<https://zhuanlan.zhihu.com/p/51838528>

传递参数可以（非必须）转移所有权

```rust
fn main() {
    let s = String::from("hello"); 
    takes_ownership(s);             //s的所有权转移进入函数，不能在main再使用s

    let x = 5;                      
    makes_copy(x);                  //x是简单类型i32, 拷贝进入函数，本身继续存在

} //x出局，退出堆栈。s出局，但没有所有权，什么都不做

fn takes_ownership(some_string: String) { // some_string得到"hello"的所有权
    println!("{}", some_string);
} // some_string出局，调用drop, 堆中"hello"内存释放

fn makes_copy(some_integer: i32) { // some_integer得到拷贝
    println!("{}", some_integer);
} //some_string出局，退出栈，没什么特别
```

返回值也可以转移所有权

```rust
fn main() {
    let s1 = gives_ownership();         // 从返回值得到所有权

    let s2 = String::from("hello");    

    let s3 = takes_and_gives_back(s2);  // s2所有权交给函数参数，s3接收返回值所有权

} //s1, s3出局，调用drop。s2所有权转移了，什么都不做

fn gives_ownership() -> String { 
    let some_string = String::from("hello"); 

    some_string                              // some_string返回并交给调用者所有权
}

fn takes_and_gives_back(a_string: String) -> String { // 接收所有权

    a_string  // 返回所有权
}
```

函数可以通过参考（改为引用）来传递参数地址，并保留所有权，即借用。

```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);  //参考，即传递地址而不是实际变量，不交出所有权，即借用

    println!("The length of '{}' is {}.", s1, len); //s1可以使用
}

fn calculate_length(s: &String) -> usize {  //参数类型需指明&
    s.len()
    //s.push_str(", world")  错误，不能改变参考除非指定mut
}
```

可变与不可变的参考

```rust
let mut s = String::from("hello");

{
    let r1 = &mut s; //可改变的参考
    let r2 = &mut s; //不可以有两个可变的参考，因为会同时改变同一块内存
}

{
    let r1 = &s; //不可变参考
    let r2 = &s; //可以有多个不可变参考
    let r3 = &mut s; //不可以同时有可变和不可变的参考，因为不可变的可能依赖原来的值
}

{
    let r1 = &mut s;
}
let r2 = &mut s; //可以，r1不存在于这个范围
```

晃荡指针，即无主的参考

```rust
fn dangle() -> &String {

    let s = String::from("hello");

    &s
} // s出局，内存释放，但是函数返回她的地址。编译错误。这种情况直接返回s
```