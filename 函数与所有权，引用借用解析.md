# 函数与所有权，引用借用

## 总结

简单类型不考虑所有权，（如果是可变引用，目前的变了并不改变原值）复杂类型直接用转移所有权，引用不转移所有权。

函数内部造的复杂类型，返回值必须返回其所有权，不能返回引用，因为出了函数，这个类型的对象就死了。。。

可变引用只能有一个，不可变引用可以有多个，不可变引用和可变引用只能二选一。

引用&写等号右边，可变引用等号两边都要加mut(等号左边是default，也可以不写)

for i in [] 的i是引用，使用时候要解引用, 且不能自动解引用

比如使用引用对象得属性等时，`.`在Rust中会自动解引用。一般情况下简单类型也会自动解引用。（for时候不行）

```rust

fn main(){
    // 简单类型
    let a = 10;
    let b = & a;
    let c = 20;
    // let d = & mut c; // 与let mut d = & mut c一样, 报错因为，引用可变类型的前提是c是可变的
    let mut d = 30;
    let mut e = &mut d; // 不用写左边的mut, 右边可以推断出现在的是可变的
    let f = &e; // 这里的mut也可以不写，可以推断现在的f可以改变原值
    //let g = &d;
    println!("{}", b);
    println!("{}", *b);
    println!("{}", e);
    println!("{}", f);
    //println!("{}", g); // 报错， 同一个变量不能同时有可变和不可变
    // 复杂类型
    struct Person{
        first_name: String,
        last_name: String,
        age: u8
    }

    // let p = Person{
    //     first_name: "Pascal".to_string(),
    //     last_name: "Precht".to_string(),
    //     age: 28
    // };

    //let r = &p; //报错，因为p不能改
    //r.age = 29
    let mut p = Person{
        first_name: "Pascal".to_string(),
        last_name: "Precht".to_string(),
        age: 28
    };
    let mut r = &mut p;
    r.age = 29;
    println!("{}", p.age);
    // let mut t = &mut r; // 报错，同一个heap不能有两个可变引用
    // t.age = 49;
}
```



<https://juejin.cn/post/6844904106310516744> //这篇文章讲的非常非常好

<https://zhuanlan.zhihu.com/p/51838528>

传递参数可以（非必须）转移所有权

```rust
fn main() {
    let s = String::from("hello"); 
    takes_ownership(s);             //s的所有权转移进入函数，不能在main再使用s

    let x = 5;                      
    makes_copy(x);                  //x是简单类型i32, 拷贝进入函数，本身继续存在

} //x出局，退出堆栈。s出局，但没有所有权，什么都不做

fn takes_ownership(some_string: String) { // some_string得到"hello"的所有权
    println!("{}", some_string);
} // some_string出局，调用drop, 堆中"hello"内存释放

fn makes_copy(some_integer: i32) { // some_integer得到拷贝
    println!("{}", some_integer);
} //some_string出局，退出栈，没什么特别
```

返回值也可以转移所有权

```rust
fn main() {
    let s1 = gives_ownership();         // 从返回值得到所有权

    let s2 = String::from("hello");    

    let s3 = takes_and_gives_back(s2);  // s2所有权交给函数参数，s3接收返回值所有权

} //s1, s3出局，调用drop。s2所有权转移了，什么都不做

fn gives_ownership() -> String { 
    let some_string = String::from("hello"); 

    some_string                              // some_string返回并交给调用者所有权
}

fn takes_and_gives_back(a_string: String) -> String { // 接收所有权

    a_string  // 返回所有权
}
```

函数可以通过参考（改为引用）来传递参数地址，并保留所有权，即借用。

```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);  //参考，即传递地址而不是实际变量，不交出所有权，即借用

    println!("The length of '{}' is {}.", s1, len); //s1可以使用
}

fn calculate_length(s: &String) -> usize {  //参数类型需指明&
    s.len()
    //s.push_str(", world")  错误，不能改变参考除非指定mut
}
```

可变与不可变的参考

```rust
let mut s = String::from("hello");

{
    let r1 = &mut s; //可改变的参考
    let r2 = &mut s; //不可以有两个可变的参考，因为会同时改变同一块内存
}

{
    let r1 = &s; //不可变参考
    let r2 = &s; //可以有多个不可变参考
    let r3 = &mut s; //不可以同时有可变和不可变的参考，因为不可变的可能依赖原来的值
}

{
    let r1 = &mut s;
}
let r2 = &mut s; //可以，r1不存在于这个范围
```

晃荡指针，即无主的参考

```rust
fn dangle() -> &String {

    let s = String::from("hello");

    &s
} // s出局，内存释放，但是函数返回她的地址。编译错误。这种情况直接返回s
```