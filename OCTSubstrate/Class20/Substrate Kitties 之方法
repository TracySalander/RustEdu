加入create方法，create方法需要一个random函数，我们在helper的部分加入
```rust
impl<T: Config> Pallet<T> {
		/// 随机数生成
		/// ### Arguments
		/// * `who` - 生成随机数的人
		fn random_value(who: &T::AccountId) -> [u8; 16] {
			let payload =
				(T::Randomness::random_seed(), &who, <frame_system::Pallet<T>>::extrinsic_index()); //extrinsic_index()是这笔交易在这个block中的index
			payload.using_encoded(blake2_128) //用上述三个值可以通过blake2_128最终产生一个128位数
		}
}

```
这里要用到Randomness需要在上面引入，并且在Config里暴露给外面，另外在runtime的Config里也需要添加
```rust
    use frame_support::{
	      dispatch::DispatchResult,
	      pallet_prelude::*,
	      traits::Randomness
    };
    use frame_system::pallet_prelude::*;
	  use sp_io::hashing::blake2_128;
```
```rust
    #[pallet::config]
	    pub trait Config: frame_system::Config {
		      // 事件 Because this pallet emits events, it depends on the runtime's definition of an event.
		    type Event: From<Event<Self>> + IsType<<Self as frame_system::Config>::Event>;
	 		/// 随机数模块
 		    type Randomness: Randomness<Self::Hash, Self::BlockNumber>;
    }
```
```rust
impl pallet_kitties::Config for Runtime {
	type Event = Event;
	type Randomness = RandomnessCollectiveFlip;
}
```
另外就是create方法里的Error和Event在对应位置要加入
```rust
    pub enum Error<T> {
		KittiesCountOverflow
    }
```
```rust
    pub enum Event<T: Config> {
		/// 创建成功 [account, kitty_id]
 		KittyCreated(T::AccountId, KittyIndex),
    }
```
同理我们加入transfer
```rust
    /// 转让 Kitty
		/// 转让者与接收者不能相同
		/// ### Arguments
		/// * `origin` - 转让者
		/// * `to` - 接收者
		/// * `kitty_id` - 转让的 Kitty 编号
		#[pallet::weight(0)]
		pub fn transfer(
			origin: OriginFor<T>,
			to: T::AccountId,
			kitty_id: KittyIndex,
		) -> DispatchResult {
			let sender = ensure_signed(origin)?;

			ensure!(sender != to, Error::<T>::SameOwner);

			let owner = Owner::<T>::get(&kitty_id).unwrap();
			ensure!(owner == sender, Error::<T>::NotOwnerOfKitty);

			Owner::<T>::insert(kitty_id, Some(to.clone()));

 			Self::deposit_event(Event::KittyTransfered(sender, to, kitty_id));
			Ok(())
		}
```
