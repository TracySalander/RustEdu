Rust:
宏
包，引入包
模块
Trait
继承
enum
pub
type
方法
函数
impl

[pallet::config]
[pallet::event]
[pallet::error]
[pallet::pallet]
[pallet::storage]
[pallet::hooks]
[pallet::call]

什么是Substrate Node Template-最小的Substrate可用Demo，方便快速入门

# 文件目录
brew install tree

tree -L 1 // 查看一级目录

# cargo.toml文件里有：
```rust
// 它和catch_unwind一起使用可以捕获某个线程内panic抛出的异常，常用的场景有：
// 在其它语言中嵌入Rust
// 自定义线程处理的逻辑
// 测试框架，因为测试用例可以panic，但是不能中断测试的运行。

[profile.release]
panic = 'unwind'

[workspace]
members = [
	'node', // 可执行程序，在对应的src/main.rs文件内拥有一个可执行的main函数入口;
	'pallets/template', // 组件库，在src/lib.rs定义了可被外部使用的函数和数据结构。
	'runtime', // 组件库，在src/lib.rs定义了可被外部使用的函数和数据结构。
]
```

# node/build.rs
自定义的构建脚本放置在项目的build.rs文件内，可以在编译构建构建项目之前，让Cargo去编译和执行该脚本，使用场景有:
* 编译、连接第三方的非Rust代码
* 构建之前的代码生成功能

# scripts/init.sh
初始化编译环境，包括升级Rust的版本，包括nightly和stable两个发布渠道，并且添加构建WebAssembly的支持工具；定期执行脚本，可以解决一些常见的编译问题如某个依赖安装失败。
```rust
rustup update nightly
rustup update stable

rustup target add wasm32-unknown-unknown --toolchain nightly
```

# pallets
包含了自定义的runtime模块，默认只有一个template模块，以此模块为例：
cargo.toml包含：
* package的基本信息如果name,version, authors等。
* package所依赖的第三方库，以frame-support为例，来源是Github上该代码仓库的缪戈commit id，并将default-features设置为false（即不使用默认的feature进行编辑）
* 通过feature进行条件编译，当使用Cargo进行构建时，下面的配置表示默认使用std feature，当编译依赖库如frame-support也默认使用std feature。这样的配置保证了runtime模块既可以编译为
Native执行版本（使用std feature），也可以便以为Wasm执行版本（使用no_std feature，并由WasmBuilder进行编译）。
```rust
[features]
default = ['std']
runtime-benchmarks = ['frame-benchmarking']
std = [
	'codec/std',
	'frame-support/std',
	'frame-system/std',
	'frame-benchmarking/std',
]
try-runtime = ['frame-support/try-runtime']
```
说明：Substrate为了保证应用的安全和稳定，对runtime有意地添加了一个约束，也就是在runtime代码里只能使用Rust的核心库及一些辅助库，而不能使用标准库。使用标准库会导致Wasn执行版本编译失败。
src/lib.rs是runtime模块的具体功能实现：
* ![cfg_attr(not(feature = "std), no_std)]表示编译时如果feature不是std，那么必须是no_std。
* mock和test模块只是运行测试时进行编译；
* 定义了模块的接口，继承自frame_system模块的接口，并添加了一个关联类型Event，这个Event类型可以转换成frame_system模块下的Event，也可以由当前的template模块定义的Event转换而来;

```rust
#[pallet::config]
pub trait Config: frame_system::Config {
	type Event: From<Event<Self>> + IsType<<Self as frame_system::Config>::Event>;
}
```

* 模块定义概览

```rust
use support::{decl_module, decl_storage, decl_event,...};
pub trait Trait: system::Trait {...}

decl_storage! {...}  // 定义模块的存储单元
decl_event!{...}  // 定义模块可以触发的事件
decl_error! {...}  // 定义模块可以返回的错误种类
decl_module! {...} // 用户可以调用的Runtime的方法，定义了本模块的核心逻辑即可调用函数（Dispatchable Call），并初始化Error类型和Event的默认触发方式。
impl<T: Trait> Module<T> {...} // 实现当前或其他模块的方法，但是用户不可调用
```
* src/mock.rs是为测试用例服务的
```rust // 创建了一个测试用的runtine结构体;
    frame_support::construct_runtime!(
	pub enum Test where
		Block = Block,
		NodeBlock = Block,
		UncheckedExtrinsic = UncheckedExtrinsic,
	{
		System: frame_system::{Pallet, Call, Config, Storage, Event<T>},
		TemplateModule: pallet_template::{Pallet, Call, Storage, Event<T>},
	}
    );
```
* 通过parameter_types宏生成一些后面功能模块所需的满足Get接口的数据类型;
```rust
parameter_types! {
	pub const BlockHashCount: u64 = 250;
	pub const SS58Prefix: u8 = 42;
}
```
* 为runtime实现各个功能模块接口，这里使用了大量的()来mock不关心的数据类型；
```rust
    impl system::Config for Test {
	type BaseCallFilter = ();
	type BlockWeights = ();
	type BlockLength = ();
	type DbWeight = ();
	type Origin = Origin;
	type Call = Call;
	type Index = u64;
	type BlockNumber = u64;
	type Hash = H256;
	type Hashing = BlakeTwo256;
	type AccountId = u64;
	type Lookup = IdentityLookup<Self::AccountId>;
	type Header = Header;
	type Event = Event;
	type BlockHashCount = BlockHashCount;
	type Version = ();
	type PalletInfo = PalletInfo;
	type AccountData = ();
	type OnNewAccount = ();
	type OnKilledAccount = ();
	type SystemWeightInfo = ();
	type SS58Prefix = SS58Prefix;
	type OnSetCode = ();
    }

```

```rust
type Block = frame_system::mocking::MockBlock<Test>;//定义别名，使测试代码更简洁
```
```rust
    pub fn new_test_ext() -> sp_io::TestExternalities { // 初始化GenesisConfig，并返回一个基于HashMap的TestExternalities，用于存储的读写和其它扩展操作。
	system::GenesisConfig::default().build_storage::<Test>().unwrap().into()
    }
```

# 引入和定义关联类型

每一个Pallet下都有一个trait，然后基本上都需要继承system::Trait

关联类型可以理解成抽象类型

```rust
pub trait Trait: system::Trait{ // inherites from system::Trait
		type Event: From<Event<Self>> + Into<<Self as system::Trait>::Event>;
}

// From system pallet
pub trait Trait: 'static + Eq + Clone{
		type Origin: ...
		type Call: ...
		type Index: ...
		type BlockNumber:(各种约束) ...//这些就是关联类型，主要是为了和其他pallet进行交互。可以给具体的类型
}
```

# 定义存储

```rust
decl_storage! { // #[pallet::storage]
	trait Store for Module<T: Trait> as TemplateModule {
      // Here we are declaring a StorageValue, Something as an Option<u32>
      // get(fn something) defines a getter function
      // Getter called with Self::thing()
      Something get(fn something): Option<u32>;
      // Here we are declaring a StorageMap SomeMap from an AccountId to a Hash
      // Getter called with Self::some_map(account_id)
      SomeMap get(fn some_map): map hasher(identity) T::AccountId => u32;
  }
}
```
存储：一个模块可以定义链上的持久化数据结构，例如映射表、列表等等。存储条目定义在decl_storage!宏里：

```rust
decl_storage!{
  trait Store for Module<T: Trait> as NFTStorage{
    TokenToOwner get(token): map T::Hash => Token<T::Hash, T::Hash>;
    TokenIndex get(get_token_by_index): map u64 => T::Hash;
    TotalTokens get(total_tokens): u64;
  }
}
```



# 定义可调用函数

```rust
decl_module! { // 我们给用户写的function
  pub struct Module<T: Trait> for enum Call where origin: T::Origin {
     fn deposit_event<T>() = default; // The default deposit_event definition
    
    // 这个地方才需要改，是用户可以调用的方法
    pub fn do_something(origin, something: u32) -> Result {
      let sender = ensure_signed(origin)?; // Check for transaction
      <Something::put(something)> // Put a value into a StorageValue
      // 调用这个方法之后用户会发出一个事件广播叫SomethingStored.
      Self::deposit_event(RawEvent::SomethingStored(something, who)); // Emit Event
      Ok(()) // Return Ok at the end of a function  
    }
  }
}
```

# 定义事件

```rust
decl_event!{ // #[pallet::event]
  	pub enum Event<T> where AccountId = <T as system::Trait>::AccountId {
      /// Event SomethingStored is declared with a parameter of the type u32 and AccountId
      SomethingStored(u32, AccountId),
  }
}
```
事件：一个模块可以声明自定义事件，当特定条件满足时触发，例如，当你铸造非同质化通证时，可能是一个TokenCreate事件。事件被封装在decl_event!宏里:
```rust
decl_event!{
		pub enum Event<T>
    where
  			<T as system::Trait>::AccoutnId,
  			<T as system::Trait>::Hash
    {
        TokenCreated(AccountId, Hash),  
    }
}
```

# 定义公共和私有函数

```rust
impl<T: Trait> Module<T>{ 
	fn mint(to: T::AccountId, id: T::Hash) -> Result {...}
	fn transfer(from: T::AccountId, to: T::AccountId, id: T::Hash) -> Result{
		...
	}
}// 如果定义为pub，其他模块也可以调用。
```

src/test.rs包含了所有的测试用例，
* 引入mock数据和断言；
* 通过#[test]来标识测试函数；
* 调用#[test]来标识测试函数；
* 调用template模块的可调用函数，并返回执行结果TemplateModule::do_something(Origin::signed(1))
* assert_ok断言结果是Ok, assert_eq断言结果等于预期，assert_noop断言结果为Error并不修改链上存储状态。

# runtime
cargo.toml除了上面提到的某个pallet对应的cargo.toml里的类似内容外，还添加了，
* 构建脚本即build.rs的依赖wasm-builder-runner；
* Substrate内置和开发者自定义的runtime模块（也叫做pallet）。
build.rs使用wasm-builder-runner将当前的runtime项目编译为Wasm，编译后的文件位于target/release/wbuild/node-template-runtime/node_template_runtime.compact.wasm.

src/lib.rs就是构造我们链上runtime的入口
* #![cfg_attr(not(feature = "std"), no_std)]表示编译时如果feature不是std，那么必须是no_std；
* #![recursion_limit="256"]用来设置编译期间可能出现无限递归操作（如宏展开）的最大阈值
* 使用std feature编译时，将生成的Wasm二进制内容通过常量的方式引入到当前runtime代码中。
```rust
#[cfg(feature = "std")]
include!(concat!(env!("OUT_DIR"), "/wasm_binary.rs"));
```
* 引入依赖的模块，以及为了下游模块方便调用而暴露上游模块的部分函数和数据类型，如pub use balances::Call as BalancesCall;
* 引入template模块pub use template;
* 给runtime所需的基础类型起别名，原则是和模块中的associate type名称一致，如pub type BlockNumber = u32;
* opaque模块封装了一些用于CLI初始化时的类型，这些类型和runtime的具体信息；
* 指定了runtime版本信息，当runtime协议修改之后，需要将spec_version加1；
 impl_version是协议的实现版本，用来表示节点运行的代码是不同的，仅当非共识相关的优化发生时才可能修改这个值；RUNTIME_API_VERSITONS包含已实现的runtime api的所有版本信息，由
 impl_runtime_apis宏生成。
```rust
// To learn more about runtime versioning and what each of the following value means:
//   https://substrate.dev/docs/en/knowledgebase/runtime/upgrades#runtime-versioning
    pub const VERSION: RuntimeVersion = RuntimeVersion {
	spec_name: create_runtime_str!("node-template"),
	impl_name: create_runtime_str!("node-template"),
	authoring_version: 1,
	// The version of the runtime specification. A full node will not attempt to use its native
	//   runtime in substitute for the on-chain Wasm runtime unless all of `spec_name`,
	//   `spec_version`, and `authoring_version` are the same between Wasm and native.
	// This value is set to 100 to notify Polkadot-JS App (https://polkadot.js.org/apps) to use
	//   the compatible custom types.
	spec_version: 100,
	impl_version: 1,
	apis: RUNTIME_API_VERSIONS,
	transaction_version: 1,
    };
```
* 定义区块时间相关的常量，如pub const MILLISECS_PER_BLOCK: u64 = 6000，即每个区块是6秒，可以根据需要修改配置；
* 指定当前的NativeVersion，在执行交易时会把NativeVersion和链上的RuntimeVersion进行比较，如果不一致，通常情况下会使用Wasm执行交易。
* 使用parameter_types宏生成一些后面功能模块所需的满足Get接口的数据类型；
* 为runtime的实现各个功能模块的接口，runtime由construct_runtime宏生成。
```rust
/// This determines the average expected block time that we are targeting.
/// Blocks will be produced at a minimum duration defined by `SLOT_DURATION`.
/// `SLOT_DURATION` is picked up by `pallet_timestamp` which is in turn picked
/// up by `pallet_aura` to implement `fn slot_duration()`.
///
/// Change this to adjust the block time.
pub const MILLISECS_PER_BLOCK: u64 = 6000;
```
```
// Configure FRAME pallets to include in runtime.

    impl frame_system::Config for Runtime {
	/// The basic call filter to use in dispatchable.
	type BaseCallFilter = ();
	/// Block & extrinsics weights: base values and limits.
	type BlockWeights = BlockWeights;
	/// The maximum length of a block (in bytes).
	type BlockLength = BlockLength;
	/// The identifier used to distinguish between accounts.
	type AccountId = AccountId;
	/// The aggregated dispatch type that is available for extrinsics.
	type Call = Call;
	/// The lookup mechanism to get account ID from whatever is passed in dispatchers.
	type Lookup = AccountIdLookup<AccountId, ()>;
	/// The index type for storing how many extrinsics an account has signed.
	type Index = Index;
	/// The index type for blocks.
	type BlockNumber = BlockNumber;
	/// The type for hashing blocks and tries.
	type Hash = Hash;
	/// The hashing algorithm used.
	type Hashing = BlakeTwo256;
	/// The header type.
	type Header = generic::Header<BlockNumber, BlakeTwo256>;
	/// The ubiquitous event type.
	type Event = Event;
	/// The ubiquitous origin type.
	type Origin = Origin;
	/// Maximum number of block number to block hash mappings to keep (oldest pruned first).
	type BlockHashCount = BlockHashCount;
	/// The weight of database operations that the runtime can invoke.
	type DbWeight = RocksDbWeight;
	/// Version of the runtime.
	type Version = Version;
	/// Converts a module to the index of the module in `construct_runtime!`.
	///
	/// This type is being generated by `construct_runtime!`.
	type PalletInfo = PalletInfo;
	/// What to do if a new account is created.
	type OnNewAccount = ();
	/// What to do if an account is fully reaped from the system.
	type OnKilledAccount = ();
	/// The data to be stored in an account.
	type AccountData = pallet_balances::AccountData<Balance>;
	/// Weight information for the extrinsics of this pallet.
	type SystemWeightInfo = ();
	/// This is used as an identifier of the chain. 42 is the generic substrate prefix.
	type SS58Prefix = SS58Prefix;
	/// The set code logic, just the default since we're not a parachain.
	type OnSetCode = ();
    }
```
* construct_runtime宏根据名称（如TemplateModule）和所用的模块内的组件（如template::(Module, Call, Storage, Event<T>)）来构造runtime，从而使模块中的信息通过
metadata暴露出来，并且使该模块在runtime中可用。构造时，是按照顺序加载初始存储的，所以当B模块依赖A模块时，应当将A模块放在B之前。
* 通过impl_runtime_apis宏实现runtime api定义的接口，这些接口需要通过decl_runtime_apis宏进行定义。
<https://github.com/SubstrateCourse/substrate_node_template>

git clone https://github.com/substrateCourse/substrate_node_template.git


Runtime定义链上逻辑，用那些Pallets，封装Pallets，在这里才规定需要使用什么模块
	
# node
cargo.toml使用[[bin]]表示这个包是可执行的，通过build-dependencies引入编译时的依赖，在build.rs中使用。
build.rs的内容和workspace跟目录下的build.rs相同。
src/main.rs是node-template编译成可执行程序的入口文件。
* #![warn(missing_docs)]在编译时，当模块缺少文档时会打印warning;
* 引入了当前目录下的其它代码模式，如mod chain_spec；
* #[macro_use]会加载引入的模块下的所有宏；
* main函数式程序的入口，它返回一个自定义的Result类型，在函数内首先构造了一个VersionInfo的结构体，用来保存可执行程序的版本信息，其中VERGEN_SHA_SHORT是在编译时由build.rs
产生的，然后执行command模块提供的run函数。
src/command.rs提供了main所需的run函数
* 通过from_args解析命令行的执行参数，返回一个cli结构体，具体参考下面src/cli.rs的内容；
* 创建一个默认的Substrate服务配置，这些服务包含启动线程运行网络、客户端和交易池等；
* 如果返回的cli实例里存在子命令，则执行子命令，执行子命令时，
// 余下内容参考Substrate代码导读: node-template
	

`cargo build --release`

'./target/release/node-template purge-chain --dev'

'./target/release/node-template --dev'

前端转账试试，然后看看链状态

写一个方法呗？

Rust主要是Trait相关需要讲一下。



介绍node, pallets, runtime都是什么（结构），然后详细读一下Pallets的lib.rs
