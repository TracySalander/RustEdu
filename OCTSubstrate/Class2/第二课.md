什么是Substrate Node Template-最小的Substrate可用Demo，方便快速入门

# 模块定义概览

```rust
use support::{decl_module, decl_storage, decl_event,...};
pub trait Trait: system::Trait {...}

decl_storage! {...}
decl_event!{...}
decl_error! {...} 
decl_module! {...} // 用户可以调用的Runtime的方法
impl<T: Trait> Module<T> {...} // 实现当前或其他模块的方法，但是用户不可调用
```

# 引入和定义关联类型

每一个Pallet下都有一个trait，然后基本上都需要继承system::Trait

关联类型可以理解成抽象类型

```rust
pub trait Trait: system::Trait{ // inherites from system::Trait
		type Event: From<Event<Self>> + Into<<Self as system::Trait>::Event>;
}

// From system pallet
pub trait Trait: 'static + Eq + Clone{
		type Origin: ...
		type Call: ...
		type Index: ...
		type BlockNumber:(各种约束) ...//这些就是关联类型，主要是为了和其他pallet进行交互。可以给具体的类型
}
```

# 定义存储

```rust
decl_storage! { // #[pallet::storage]
	trait Store for Module<T: Trait> as TemplateModule {
      // Here we are declaring a StorageValue, Something as an Option<u32>
      // get(fn something) defines a getter function
      // Getter called with Self::thing()
      Something get(fn something): Option<u32>;
      // Here we are declaring a StorageMap SomeMap from an AccountId to a Hash
      // Getter called with Self::some_map(account_id)
      SomeMap get(fn some_map): map hasher(identity) T::AccountId => u32;
  }
}
```
存储：一个模块可以定义链上的持久化数据结构，例如映射表、列表等等。存储条目定义在decl_storage!宏里：

```rust
decl_storage!{
  trait Store for Module<T: Trait> as NFTStorage{
    TokenToOwner get(token): map T::Hash => Token<T::Hash, T::Hash>;
    TokenIndex get(get_token_by_index): map u64 => T::Hash;
    TotalTokens get(total_tokens): u64;
  }
}
```



# 定义可调用函数

```rust
decl_module! { // 我们给用户写的function
  pub struct Module<T: Trait> for enum Call where origin: T::Origin {
     fn deposit_event<T>() = default; // The default deposit_event definition
    
    // 这个地方才需要改，是用户可以调用的方法
    pub fn do_something(origin, something: u32) -> Result {
      let sender = ensure_signed(origin)?; // Check for transaction
      <Something::put(something)> // Put a value into a StorageValue
      // 调用这个方法之后用户会发出一个事件广播叫SomethingStored.
      Self::deposit_event(RawEvent::SomethingStored(something, who)); // Emit Event
      Ok(()) // Return Ok at the end of a function  
    }
  }
}
```

# 定义事件

```rust
decl_event!{ // #[pallet::event]
  	pub enum Event<T> where AccountId = <T as system::Trait>::AccountId {
      /// Event SomethingStored is declared with a parameter of the type u32 and AccountId
      SomethingStored(u32, AccountId),
  }
}
```
事件：一个模块可以声明自定义事件，当特定条件满足时触发，例如，当你铸造非同质化通证时，可能是一个TokenCreate事件。事件被封装在decl_event!宏里:
```rust
decl_event!{
		pub enum Event<T>
    where
  			<T as system::Trait>::AccoutnId,
  			<T as system::Trait>::Hash
    {
        TokenCreated(AccountId, Hash),  
    }
}
```

# 定义公共和私有函数

```rust
impl<T: Trait> Module<T>{ 
	fn mint(to: T::AccountId, id: T::Hash) -> Result {...}
	fn transfer(from: T::AccountId, to: T::AccountId, id: T::Hash) -> Result{
		...
	}
}// 如果定义为pub，其他模块也可以调用。
```



<https://github.com/SubstrateCourse/substrate_node_template>

git clone https://github.com/substrateCourse/substrate_node_template.git



Runtime定义链上逻辑，用那些Pallets，封装Pallets，在这里才规定需要使用什么模块

`cargo build --release`

'./target/release/node-template purge-chain --dev'

'./target/release/node-template --dev'

前端转账试试，然后看看链状态

写一个方法呗？

Rust主要是Trait相关需要讲一下。



介绍node, pallets, runtime都是什么（结构），然后详细读一下Pallets的lib.rs
