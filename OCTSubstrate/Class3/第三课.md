# runtime
cargo.toml除了上面提到的某个pallet对应的cargo.toml里的类似内容外，还添加了，
* 构建脚本即build.rs的依赖wasm-builder-runner；
* Substrate内置和开发者自定义的runtime模块（也叫做pallet）。
build.rs使用wasm-builder-runner将当前的runtime项目编译为Wasm，编译后的文件位于target/release/wbuild/node-template-runtime/node_template_runtime.compact.wasm.

src/lib.rs就是构造我们链上runtime的入口
* #![cfg_attr(not(feature = "std"), no_std)]表示编译时如果feature不是std，那么必须是no_std；
* #![recursion_limit="256"]用来设置编译期间可能出现无限递归操作（如宏展开）的最大阈值
* 使用std feature编译时，将生成的Wasm二进制内容通过常量的方式引入到当前runtime代码中。
```rust
#[cfg(feature = "std")]
include!(concat!(env!("OUT_DIR"), "/wasm_binary.rs"));
```
* 引入依赖的模块，以及为了下游模块方便调用而暴露上游模块的部分函数和数据类型，如pub use balances::Call as BalancesCall;
* 引入template模块pub use template;
* 给runtime所需的基础类型起别名，原则是和模块中的associate type名称一致，如pub type BlockNumber = u32;
* opaque模块封装了一些用于CLI初始化时的类型，这些类型和runtime的具体信息；
* 指定了runtime版本信息，当runtime协议修改之后，需要将spec_version加1；
 impl_version是协议的实现版本，用来表示节点运行的代码是不同的，仅当非共识相关的优化发生时才可能修改这个值；RUNTIME_API_VERSITONS包含已实现的runtime api的所有版本信息，由
 impl_runtime_apis宏生成。
```rust
// To learn more about runtime versioning and what each of the following value means:
//   https://substrate.dev/docs/en/knowledgebase/runtime/upgrades#runtime-versioning
    pub const VERSION: RuntimeVersion = RuntimeVersion {
	spec_name: create_runtime_str!("node-template"),
	impl_name: create_runtime_str!("node-template"),
	authoring_version: 1,
	// The version of the runtime specification. A full node will not attempt to use its native
	//   runtime in substitute for the on-chain Wasm runtime unless all of `spec_name`,
	//   `spec_version`, and `authoring_version` are the same between Wasm and native.
	// This value is set to 100 to notify Polkadot-JS App (https://polkadot.js.org/apps) to use
	//   the compatible custom types.
	spec_version: 100,
	impl_version: 1,
	apis: RUNTIME_API_VERSIONS,
	transaction_version: 1,
    };
```
* 定义区块时间相关的常量，如pub const MILLISECS_PER_BLOCK: u64 = 6000，即每个区块是6秒，可以根据需要修改配置；
* 指定当前的NativeVersion，在执行交易时会把NativeVersion和链上的RuntimeVersion进行比较，如果不一致，通常情况下会使用Wasm执行交易。
* 使用parameter_types宏生成一些后面功能模块所需的满足Get接口的数据类型；
* 为runtime的实现各个功能模块的接口，runtime由construct_runtime宏生成。
```rust
/// This determines the average expected block time that we are targeting.
/// Blocks will be produced at a minimum duration defined by `SLOT_DURATION`.
/// `SLOT_DURATION` is picked up by `pallet_timestamp` which is in turn picked
/// up by `pallet_aura` to implement `fn slot_duration()`.
///
/// Change this to adjust the block time.
pub const MILLISECS_PER_BLOCK: u64 = 6000;
```
```
// Configure FRAME pallets to include in runtime.

    impl frame_system::Config for Runtime {
	/// The basic call filter to use in dispatchable.
	type BaseCallFilter = ();
	/// Block & extrinsics weights: base values and limits.
	type BlockWeights = BlockWeights;
	/// The maximum length of a block (in bytes).
	type BlockLength = BlockLength;
	/// The identifier used to distinguish between accounts.
	type AccountId = AccountId;
	/// The aggregated dispatch type that is available for extrinsics.
	type Call = Call;
	/// The lookup mechanism to get account ID from whatever is passed in dispatchers.
	type Lookup = AccountIdLookup<AccountId, ()>;
	/// The index type for storing how many extrinsics an account has signed.
	type Index = Index;
	/// The index type for blocks.
	type BlockNumber = BlockNumber;
	/// The type for hashing blocks and tries.
	type Hash = Hash;
	/// The hashing algorithm used.
	type Hashing = BlakeTwo256;
	/// The header type.
	type Header = generic::Header<BlockNumber, BlakeTwo256>;
	/// The ubiquitous event type.
	type Event = Event;
	/// The ubiquitous origin type.
	type Origin = Origin;
	/// Maximum number of block number to block hash mappings to keep (oldest pruned first).
	type BlockHashCount = BlockHashCount;
	/// The weight of database operations that the runtime can invoke.
	type DbWeight = RocksDbWeight;
	/// Version of the runtime.
	type Version = Version;
	/// Converts a module to the index of the module in `construct_runtime!`.
	///
	/// This type is being generated by `construct_runtime!`.
	type PalletInfo = PalletInfo;
	/// What to do if a new account is created.
	type OnNewAccount = ();
	/// What to do if an account is fully reaped from the system.
	type OnKilledAccount = ();
	/// The data to be stored in an account.
	type AccountData = pallet_balances::AccountData<Balance>;
	/// Weight information for the extrinsics of this pallet.
	type SystemWeightInfo = ();
	/// This is used as an identifier of the chain. 42 is the generic substrate prefix.
	type SS58Prefix = SS58Prefix;
	/// The set code logic, just the default since we're not a parachain.
	type OnSetCode = ();
    }
```
* construct_runtime宏根据名称（如TemplateModule）和所用的模块内的组件（如template::(Module, Call, Storage, Event<T>)）来构造runtime，从而使模块中的信息通过
metadata暴露出来，并且使该模块在runtime中可用。构造时，是按照顺序加载初始存储的，所以当B模块依赖A模块时，应当将A模块放在B之前。
* 通过impl_runtime_apis宏实现runtime api定义的接口，这些接口需要通过decl_runtime_apis宏进行定义。
<https://github.com/SubstrateCourse/substrate_node_template>

git clone https://github.com/substrateCourse/substrate_node_template.git



Runtime定义链上逻辑，用那些Pallets，封装Pallets，在这里才规定需要使用什么模块

# node
node
cargo.toml 使用[[bin]]表示这个包是可执行的，通过build-dependencies引入编译时的依赖，在build.rs中使用，其它内容在前面的章节已经介绍过了。

build.rs 的内容和workspace根目录下的build.rs相同。

src/main.rs 是node-template编译成可执行程序的入口文件，

#![warn(missing_docs)]在编译时，当模块缺少文档时会打印warnning；
引入了当前目录下的其它代码模块，如mod chain_spec；
#[macro_use]会加载引入的模块下的所有宏；
main函数是程序的入口，它返回一个自定义的Result类型，在函数内首先构造了一个VersionInfo的结构体，用来保存可执行程序的版本信息，其中VERGEN_SHA_SHORT是在编译时由build.rs产生的，然后执行command模块提供的run函数。
src/command.rs 提供了main所需的run函数，

通过from_args解析命令行的执行参数，返回一个Cli结构体，具体参考下面src/cli.rs的内容；
创建一个默认的Substrate服务配置，这些服务包含启动线程运行网络、客户端和交易池等；
如果返回的Cli实例里存在子命令，则执行子命令，执行子命令时，
首先进行初始化，如设置panic的异常处理机制，日志等；
通过chain_spec::load_spec获取chain的配置，来更新前面构造的Substrate服务配置；
调用子命令的run函数来执行该命令，run函数依赖src/service.rs模块里的new_full_start宏来返回ServiceBuilder，包含了构建Substrate服务的多种组件。
如果返回的Cli实例里没有子命令，则执行当前命令，
首先初始化，和子命令的初始化功能一样；
更新Substrate服务配置，比子命令的更新操作更全面，配置的所有属性都会更新；
调用run来启动节点，需要传入全节点客户端的服务实例和轻节点客户端的服务实例，根据服务配置中的节点角色进行选择，启动完成后，保持运行直到接收到退出信号SIGINT（即Ctrl+C）。
src/cli.rs 借助StructOpt库将命令行参数解析为Cli结构体，包含：

可选的子命令，如purge-chain清空本地存储，build-spec创建一个spec.json的初始文件，revert回滚链上状态等；
命令行参数，如--validator开启验证人模式，--light以轻客户端方式运行，--ws-port 9944指定WebSocket监听的TCP端口，等等。编译node-template之后，可以通过./target/release/node-template -h获取所有可用的子命令和参数，及其帮助信息。
#[derive(Debug, StructOpt)]
pub struct Cli {
    #[structopt(subcommand)]
    pub subcommand: Option<Subcommand>,

    #[structopt(flatten)]
    pub run: RunCmd,
}
chain_spec.rs 构造了ChainSpec，它定义了链的可用配置，用来构造初始区块，

node-template提供了两种模式，通过命令行参数--dev指定开发者网络（Development），只有Alice是验证人；--local指定本地测试网络（LocalTestnet），Alice和Bob是验证人；
调用ChainSpec::from_genesis创建硬编码的ChainSpec；
定义了testnet_genesis函数，传入验证人列表、root账户、存有余额的账户列表，构造出GenesisConfig。
service.rs 提供了构造Substrate服务的帮助方法，

使用native_executor_instance宏定义了一个结构体Executor，并且实现了NativeExecutionDispatch接口，即可以通过函数名称来调用该函数；
new_full_start宏构建了一个ServiceBuilder，用来构造全节点服务，过程如下：
调用with_select_chain设置链的生成策略，也就是当链出现分叉的时候，选择哪个链继续工作，这里使用最长链原则；
调用with_transaction_pool 设置交易池类型，这里使用BasicPool；
调用with_import_queue 设置了导入区块所需的队列，这里使用BasicQueue，可以顺序地导入block。
使用new_full构建一个全节点服务，
使用new_full_start宏构建了一个ServiceBuilder；
调用with_finality_proof_provider设置使用何种策略提供最终性验证；
调用build构建真正的Substrate Service；
如果是验证人并且不是哨兵模式，调用service的spawn_essential_task函数，启动用于生成区块的后台任务，使用的是Aura算法；
如果GRANDPA功能没有关闭，调用spawn_essential_task开启后台运行的投票任务。
使用new_light构建一个轻节点服务，
调用with_select_chain设置跟随最长链；
调用with_transaction_pool设置BasicPool交易池类型;
调用with_import_queue_and_fprb设置区块导入时所用的队列，以及用来构建最终性验证请求的FinalityProofRequestBuilder；
调用with_finality_proof_provider设置使用何种策略提供最终性验证；
调用build构建真正的Substrate Service。
